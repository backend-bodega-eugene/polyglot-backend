// Package logger provides structured console and file logging utilities.
package logger

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"time"
)

const (
	INFO  = "INFO"
	WARN  = "WARN"
	ERROR = "ERROR"
	DEBUG = "DEBUG"
)

var (
	logFile   *os.File
	fileMutex sync.Mutex
)

// padRight pads a string to the specified length with spaces.
func padRight(s string, length int) string {
	if len(s) >= length {
		return s
	}
	return s + strings.Repeat(" ", length-len(s))
}

// SetLogFile initializes the log file with a timestamped filename based on the project name.
// Automatically creates the logs directory if it does not exist.
func SetLogFile() error {
	fileMutex.Lock()
	defer fileMutex.Unlock()

	logDir := "logs"
	if err := os.MkdirAll(logDir, os.ModePerm); err != nil {
		return err
	}

	timespan := time.Now().Format("2006y-01m-02M-15h-04m-05s")
	filename := filepath.Join(logDir, getProjectName()+"_"+timespan+".log")
	err := os.MkdirAll(filepath.Dir(filename), os.ModePerm)
	if err != nil {
		return err
	}

	file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}

	logFile = file
	return nil
}

// SetLogFileBySelefPath sets the log file manually to a specific file path.
// It creates the directory if it does not exist.
func SetLogFileBySelefPath(eugenefilepath string) error {
	fileMutex.Lock()
	defer fileMutex.Unlock()
	// 只创建目录部分
	dir := filepath.Dir(eugenefilepath)
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return err
	}

	file, err := os.OpenFile(eugenefilepath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}

	logFile = file
	return nil
}

// writeLog outputs the formatted log message to both the console and, if configured, to a file.
func writeLog(level string, thread string, module string, message string) {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	thread = padRight(thread, 10)
	level = padRight(level, 5)
	module = padRight(module, 30)

	// Example: 2025-08-07 23:55:03 [main     ] INFO  com.eugene.utils.StringUtils - Message
	logLine := fmt.Sprintf("%s [%s] %s %s - %s", timestamp, thread, level, module, message)

	fmt.Println(logLine)

	if logFile != nil {
		fileMutex.Lock()
		defer fileMutex.Unlock()
		log.SetOutput(logFile)
		log.Println(logLine)
	}
}

// Info logs a message with INFO level, allowing manual thread and module input.
func Info(thread string, module string, message string) {
	writeLog(INFO, thread, module, message)
}

// InfoThreadname logs an INFO message with hardcoded thread info, and custom module name.
func InfoThreadname(module string, message string) {
	defer getGID()
	writeLog(INFO, "i dont know the thread name ,dont bother me", module, message)
}

// InfoThreadnameAndModulename logs an INFO message with autogenerated caller info (module + file).
func InfoThreadnameAndModulename(message string) {
	defer getGID()
	writeLog(INFO, "i dont know the thread name ,dont bother me", getCallerInfo(), message)
}

// InfoWritefle writes the message to a specific log file if provided, and logs it as INFO level.
func InfoWritefle(message string, logfileName string) {
	defer getGID()
	if "" != logfileName {
		fopen, err := os.OpenFile(logfileName+".log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err == nil {
			defer fopen.Close()
			fmt.Fprintln(fopen, message)
		}
	}
	writeLog(INFO, "i dont know the thread name ,dont bother me", getCallerInfo(), message)
}

// Warn logs a WARN level message.
func Warn(thread string, module string, message string) {
	writeLog(WARN, thread, module, message)
}

// Error logs an ERROR level message.
func Error(thread string, module string, message string) {
	writeLog(ERROR, thread, module, message)
}

// Debug logs a DEBUG level message.
func Debug(thread string, module string, message string) {
	writeLog(DEBUG, thread, module, message)
}

// getCallerInfo returns the file name, line number, and function name of the caller.
// Used for automatically filling in module name.
func getCallerInfo() string {
	pc, file, line, ok := runtime.Caller(2)
	if !ok {
		return "unknown.unknown"
	}
	funcName := runtime.FuncForPC(pc).Name()
	fileName := filepath.Base(file)
	return fmt.Sprintf("%s:%d (%s)", fileName, line, funcName)
}

// getGID returns the current goroutine ID using runtime.Stack hack.
// Not recommended for production use; mainly for debugging purposes.
func getGID() string {
	b := make([]byte, 64)
	b = b[:runtime.Stack(b, false)]
	var id uint64
	fmt.Sscanf(string(b), "goroutine %d ", &id)
	return strconv.FormatInt(int64(id), 10)
}

// getProjectName retrieves the current working directory name as project name.
func getProjectName() string {
	wd, err := os.Getwd()
	if err != nil {
		return "unknown"
	}
	return filepath.Base(wd)
}
